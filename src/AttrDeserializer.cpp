/* Autogenerated by mlir-tblgen; don't manually edit. */
// clang-format off

#include "cir-tac/AttrDeserializer.h"
#include "cir-tac/EnumDeserializer.h"
#include "mlir/IR/Attributes.h"
#include "proto/attr.pb.h"

#include <llvm/ADT/TypeSwitch.h>
#include <mlir/AsmParser/AsmParser.h>

using namespace protocir;
using mlir::Attribute;

mlir::NamedAttribute AttrDeserializer::deserializeMLIRNamedAttr(ModuleInfo &mInfo, MLIRNamedAttr pAttr) {
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.name());
  mlir::Attribute valueDeser;
  switch (pAttr.value_case()) {
    case (MLIRNamedAttr::ValueCase::kValueAttr):
      valueDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, pAttr.value_attr());
      break;
    case (MLIRNamedAttr::ValueCase::kRawAttr):
      valueDeser = mlir::parseAttribute(pAttr.raw_attr(), &mInfo.ctx);
      break;
    case (MLIRNamedAttr::ValueCase::VALUE_NOT_SET):
      llvm_unreachable("NYI!");
      break;
  }
  return mlir::NamedAttribute(nameDeser, valueDeser);
}

mlir::CallSiteLoc AttrDeserializer::deserializeMLIRCallSiteLoc(ModuleInfo &mInfo, MLIRCallSiteLoc pAttr) {
  auto calleeDeser = AttrDeserializer::deserializeMLIRLocation(mInfo, pAttr.callee());
  auto callerDeser = AttrDeserializer::deserializeMLIRLocation(mInfo, pAttr.caller());
  return mlir::CallSiteLoc::get(calleeDeser, callerDeser);
}

mlir::FileLineColLoc AttrDeserializer::deserializeMLIRFileLineColLoc(ModuleInfo &mInfo, MLIRFileLineColLoc pAttr) {
  auto filenameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.filename());
  auto lineDeser = pAttr.line();
  auto columnDeser = pAttr.column();
  return mlir::FileLineColLoc::get(&mInfo.ctx, filenameDeser, lineDeser, columnDeser);
}

mlir::FusedLoc AttrDeserializer::deserializeMLIRFusedLoc(ModuleInfo &mInfo, MLIRFusedLoc pAttr) {
  std::vector<mlir::Location> locationsDeser;
  for (auto i = 0; i < pAttr.locations_size(); i++) {
    auto elem = pAttr.locations(i);
    locationsDeser.push_back(AttrDeserializer::deserializeMLIRLocation(mInfo, elem));
  }

  Attribute metadataDeser;
  if (pAttr.has_metadata()) {
    auto elem = pAttr.metadata();
    metadataDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, elem);
  }
  return mlir::FusedLoc::get(&mInfo.ctx, locationsDeser, metadataDeser);
}

mlir::NameLoc AttrDeserializer::deserializeMLIRNameLoc(ModuleInfo &mInfo, MLIRNameLoc pAttr) {
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.name());
  auto childLocDeser = AttrDeserializer::deserializeMLIRLocation(mInfo, pAttr.child_loc());
  return mlir::NameLoc::get(nameDeser, childLocDeser);
}

mlir::OpaqueLoc AttrDeserializer::deserializeMLIROpaqueLoc(ModuleInfo &mInfo, MLIROpaqueLoc pAttr) {
  auto fallbackLocationDeser = AttrDeserializer::deserializeMLIRLocation(mInfo, pAttr.fallback_location());
  return mlir::OpaqueLoc::get(&mInfo.ctx, fallbackLocationDeser);
}

mlir::UnknownLoc AttrDeserializer::deserializeMLIRUnknownLoc(ModuleInfo &mInfo, MLIRUnknownLoc pAttr) {
  return mlir::UnknownLoc::get(&mInfo.ctx);
}

mlir::Attribute AttrDeserializer::deserializeMLIRAttribute(ModuleInfo &mInfo, MLIRAttribute pAttr) {
  switch (pAttr.attribute_case()) {
    case MLIRAttribute::AttributeCase::kArrayAttr: {
      return deserializeMLIRArrayAttr(mInfo, pAttr.array_attr());
    } break;
    case MLIRAttribute::AttributeCase::kDictionaryAttr: {
      return deserializeMLIRDictionaryAttr(mInfo, pAttr.dictionary_attr());
    } break;
    case MLIRAttribute::AttributeCase::kFloatAttr: {
      return deserializeMLIRFloatAttr(mInfo, pAttr.float_attr());
    } break;
    case MLIRAttribute::AttributeCase::kIntegerAttr: {
      return deserializeMLIRIntegerAttr(mInfo, pAttr.integer_attr());
    } break;
    case MLIRAttribute::AttributeCase::kStringAttr: {
      return deserializeMLIRStringAttr(mInfo, pAttr.string_attr());
    } break;
    case MLIRAttribute::AttributeCase::kTypeAttr: {
      return deserializeMLIRTypeAttr(mInfo, pAttr.type_attr());
    } break;
    case MLIRAttribute::AttributeCase::kUnitAttr: {
      return deserializeMLIRUnitAttr(mInfo, pAttr.unit_attr());
    } break;
    case MLIRAttribute::AttributeCase::kFlatSymbolRefAttr: {
      return deserializeMLIRFlatSymbolRefAttr(mInfo, pAttr.flat_symbol_ref_attr());
    } break;
    case MLIRAttribute::AttributeCase::kDenseI32ArrayAttr: {
      return deserializeMLIRDenseI32ArrayAttr(mInfo, pAttr.dense_i32_array_attr());
    } break;
    case MLIRAttribute::AttributeCase::kLocation: {
      return deserializeMLIRLocation(mInfo, pAttr.location());
    } break;
    case MLIRAttribute::AttributeCase::kLangAttr: {
      return deserializeCIRLangAttr(mInfo, pAttr.lang_attr());
    } break;
    case MLIRAttribute::AttributeCase::kAddressSpaceAttr: {
      return deserializeCIRAddressSpaceAttr(mInfo, pAttr.address_space_attr());
    } break;
    case MLIRAttribute::AttributeCase::kAnnotationAttr: {
      return deserializeCIRAnnotationAttr(mInfo, pAttr.annotation_attr());
    } break;
    case MLIRAttribute::AttributeCase::kBitfieldInfoAttr: {
      return deserializeCIRBitfieldInfoAttr(mInfo, pAttr.bitfield_info_attr());
    } break;
    case MLIRAttribute::AttributeCase::kBoolAttr: {
      return deserializeCIRBoolAttr(mInfo, pAttr.bool_attr());
    } break;
    case MLIRAttribute::AttributeCase::kTbaaAttr: {
      return deserializeCIRTBAAAttr(mInfo, pAttr.tbaa_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCatchAllAttr: {
      return deserializeCIRCatchAllAttr(mInfo, pAttr.catch_all_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCatchUnwindAttr: {
      return deserializeCIRCatchUnwindAttr(mInfo, pAttr.catch_unwind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCmpThreeWayInfoAttr: {
      return deserializeCIRCmpThreeWayInfoAttr(mInfo, pAttr.cmp_three_way_info_attr());
    } break;
    case MLIRAttribute::AttributeCase::kComplexAttr: {
      return deserializeCIRComplexAttr(mInfo, pAttr.complex_attr());
    } break;
    case MLIRAttribute::AttributeCase::kConstArrayAttr: {
      return deserializeCIRConstArrayAttr(mInfo, pAttr.const_array_attr());
    } break;
    case MLIRAttribute::AttributeCase::kConstPtrAttr: {
      return deserializeCIRConstPtrAttr(mInfo, pAttr.const_ptr_attr());
    } break;
    case MLIRAttribute::AttributeCase::kConstStructAttr: {
      return deserializeCIRConstStructAttr(mInfo, pAttr.const_struct_attr());
    } break;
    case MLIRAttribute::AttributeCase::kConstVectorAttr: {
      return deserializeCIRConstVectorAttr(mInfo, pAttr.const_vector_attr());
    } break;
    case MLIRAttribute::AttributeCase::kConvergentAttr: {
      return deserializeCIRConvergentAttr(mInfo, pAttr.convergent_attr());
    } break;
    case MLIRAttribute::AttributeCase::kDataMemberAttr: {
      return deserializeCIRDataMemberAttr(mInfo, pAttr.data_member_attr());
    } break;
    case MLIRAttribute::AttributeCase::kDynamicCastInfoAttr: {
      return deserializeCIRDynamicCastInfoAttr(mInfo, pAttr.dynamic_cast_info_attr());
    } break;
    case MLIRAttribute::AttributeCase::kExtraFuncAttributesAttr: {
      return deserializeCIRExtraFuncAttributesAttr(mInfo, pAttr.extra_func_attributes_attr());
    } break;
    case MLIRAttribute::AttributeCase::kFpAttr: {
      return deserializeCIRFPAttr(mInfo, pAttr.fp_attr());
    } break;
    case MLIRAttribute::AttributeCase::kGlobalAnnotationValuesAttr: {
      return deserializeCIRGlobalAnnotationValuesAttr(mInfo, pAttr.global_annotation_values_attr());
    } break;
    case MLIRAttribute::AttributeCase::kGlobalCtorAttr: {
      return deserializeCIRGlobalCtorAttr(mInfo, pAttr.global_ctor_attr());
    } break;
    case MLIRAttribute::AttributeCase::kGlobalDtorAttr: {
      return deserializeCIRGlobalDtorAttr(mInfo, pAttr.global_dtor_attr());
    } break;
    case MLIRAttribute::AttributeCase::kGlobalViewAttr: {
      return deserializeCIRGlobalViewAttr(mInfo, pAttr.global_view_attr());
    } break;
    case MLIRAttribute::AttributeCase::kInactiveUnionFieldAttr: {
      return deserializeCIRInactiveUnionFieldAttr(mInfo, pAttr.inactive_union_field_attr());
    } break;
    case MLIRAttribute::AttributeCase::kInlineAttr: {
      return deserializeCIRInlineAttr(mInfo, pAttr.inline_attr());
    } break;
    case MLIRAttribute::AttributeCase::kIntAttr: {
      return deserializeCIRIntAttr(mInfo, pAttr.int_attr());
    } break;
    case MLIRAttribute::AttributeCase::kMethodAttr: {
      return deserializeCIRMethodAttr(mInfo, pAttr.method_attr());
    } break;
    case MLIRAttribute::AttributeCase::kNoThrowAttr: {
      return deserializeCIRNoThrowAttr(mInfo, pAttr.no_throw_attr());
    } break;
    case MLIRAttribute::AttributeCase::kOpenClKernelArgMetadataAttr: {
      return deserializeCIROpenCLKernelArgMetadataAttr(mInfo, pAttr.open_cl_kernel_arg_metadata_attr());
    } break;
    case MLIRAttribute::AttributeCase::kOpenClKernelAttr: {
      return deserializeCIROpenCLKernelAttr(mInfo, pAttr.open_cl_kernel_attr());
    } break;
    case MLIRAttribute::AttributeCase::kOpenClKernelMetadataAttr: {
      return deserializeCIROpenCLKernelMetadataAttr(mInfo, pAttr.open_cl_kernel_metadata_attr());
    } break;
    case MLIRAttribute::AttributeCase::kOpenClKernelUniformWorkGroupSizeAttr: {
      return deserializeCIROpenCLKernelUniformWorkGroupSizeAttr(mInfo, pAttr.open_cl_kernel_uniform_work_group_size_attr());
    } break;
    case MLIRAttribute::AttributeCase::kOpenClVersionAttr: {
      return deserializeCIROpenCLVersionAttr(mInfo, pAttr.open_cl_version_attr());
    } break;
    case MLIRAttribute::AttributeCase::kOptNoneAttr: {
      return deserializeCIROptNoneAttr(mInfo, pAttr.opt_none_attr());
    } break;
    case MLIRAttribute::AttributeCase::kStructLayoutAttr: {
      return deserializeCIRStructLayoutAttr(mInfo, pAttr.struct_layout_attr());
    } break;
    case MLIRAttribute::AttributeCase::kTypeInfoAttr: {
      return deserializeCIRTypeInfoAttr(mInfo, pAttr.type_info_attr());
    } break;
    case MLIRAttribute::AttributeCase::kUndefAttr: {
      return deserializeCIRUndefAttr(mInfo, pAttr.undef_attr());
    } break;
    case MLIRAttribute::AttributeCase::kVTableAttr: {
      return deserializeCIRVTableAttr(mInfo, pAttr.v_table_attr());
    } break;
    case MLIRAttribute::AttributeCase::kVisibilityAttr: {
      return deserializeCIRVisibilityAttr(mInfo, pAttr.visibility_attr());
    } break;
    case MLIRAttribute::AttributeCase::kZeroAttr: {
      return deserializeCIRZeroAttr(mInfo, pAttr.zero_attr());
    } break;
    case MLIRAttribute::AttributeCase::kAsmFlavorAttr: {
      return deserializeCIRAsmFlavorAttr(mInfo, pAttr.asm_flavor_attr());
    } break;
    case MLIRAttribute::AttributeCase::kAtomicFetchKindAttr: {
      return deserializeCIRAtomicFetchKindAttr(mInfo, pAttr.atomic_fetch_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kAwaitKindAttr: {
      return deserializeCIRAwaitKindAttr(mInfo, pAttr.await_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kBinOpKindAttr: {
      return deserializeCIRBinOpKindAttr(mInfo, pAttr.bin_op_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kBinOpOverflowKindAttr: {
      return deserializeCIRBinOpOverflowKindAttr(mInfo, pAttr.bin_op_overflow_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCallingConvAttr: {
      return deserializeCIRCallingConvAttr(mInfo, pAttr.calling_conv_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCaseOpKindAttr: {
      return deserializeCIRCaseOpKindAttr(mInfo, pAttr.case_op_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCastKindAttr: {
      return deserializeCIRCastKindAttr(mInfo, pAttr.cast_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCatchParamKindAttr: {
      return deserializeCIRCatchParamKindAttr(mInfo, pAttr.catch_param_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCmpOpKindAttr: {
      return deserializeCIRCmpOpKindAttr(mInfo, pAttr.cmp_op_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kCmpOrderingAttr: {
      return deserializeCIRCmpOrderingAttr(mInfo, pAttr.cmp_ordering_attr());
    } break;
    case MLIRAttribute::AttributeCase::kComplexBinOpKindAttr: {
      return deserializeCIRComplexBinOpKindAttr(mInfo, pAttr.complex_bin_op_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kComplexRangeKindAttr: {
      return deserializeCIRComplexRangeKindAttr(mInfo, pAttr.complex_range_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kDynamicCastKindAttr: {
      return deserializeCIRDynamicCastKindAttr(mInfo, pAttr.dynamic_cast_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kGlobalLinkageKindAttr: {
      return deserializeCIRGlobalLinkageKindAttr(mInfo, pAttr.global_linkage_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kInlineKindAttr: {
      return deserializeCIRInlineKindAttr(mInfo, pAttr.inline_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kMemOrderAttr: {
      return deserializeCIRMemOrderAttr(mInfo, pAttr.mem_order_attr());
    } break;
    case MLIRAttribute::AttributeCase::kSignedOverflowBehaviorAttr: {
      return deserializeCIRSignedOverflowBehaviorAttr(mInfo, pAttr.signed_overflow_behavior_attr());
    } break;
    case MLIRAttribute::AttributeCase::kSizeInfoTypeAttr: {
      return deserializeCIRSizeInfoTypeAttr(mInfo, pAttr.size_info_type_attr());
    } break;
    case MLIRAttribute::AttributeCase::kSourceLanguageAttr: {
      return deserializeCIRSourceLanguageAttr(mInfo, pAttr.source_language_attr());
    } break;
    case MLIRAttribute::AttributeCase::kTlsModelAttr: {
      return deserializeCIRTLSModelAttr(mInfo, pAttr.tls_model_attr());
    } break;
    case MLIRAttribute::AttributeCase::kUnaryOpKindAttr: {
      return deserializeCIRUnaryOpKindAttr(mInfo, pAttr.unary_op_kind_attr());
    } break;
    case MLIRAttribute::AttributeCase::kVisibilityKindAttr: {
      return deserializeCIRVisibilityKindAttr(mInfo, pAttr.visibility_kind_attr());
    } break;
    default:
      llvm_unreachable("NYI");
      break;
  }
}

mlir::ArrayAttr AttrDeserializer::deserializeMLIRArrayAttr(ModuleInfo &mInfo, MLIRArrayAttr pAttr) {
  std::vector<mlir::Attribute> valueDeser;
  for (auto i = 0; i < pAttr.value_size(); i++) {
    auto elem = pAttr.value(i);
    valueDeser.push_back(AttrDeserializer::deserializeMLIRAttribute(mInfo, elem));
  }
  return mlir::ArrayAttr::get(&mInfo.ctx, valueDeser);
}

mlir::DictionaryAttr AttrDeserializer::deserializeMLIRDictionaryAttr(ModuleInfo &mInfo, MLIRDictionaryAttr pAttr) {
  std::vector<mlir::NamedAttribute> valueDeser;
  for (auto i = 0; i < pAttr.value_size(); i++) {
    auto elem = pAttr.value(i);
    valueDeser.push_back(AttrDeserializer::deserializeMLIRNamedAttr(mInfo, elem));
  }
  return mlir::DictionaryAttr::get(&mInfo.ctx, valueDeser);
}

mlir::FloatAttr AttrDeserializer::deserializeMLIRFloatAttr(ModuleInfo &mInfo, MLIRFloatAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto valueDeser = deserializeAPFloat(pAttr.value());
  return mlir::FloatAttr::get(mlir::cast<mlir::Type>(typeDeser), valueDeser);
}

mlir::IntegerAttr AttrDeserializer::deserializeMLIRIntegerAttr(ModuleInfo &mInfo, MLIRIntegerAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto valueDeser = deserializeAPInt(typeDeser, pAttr.value());
  return mlir::IntegerAttr::get(mlir::cast<mlir::Type>(typeDeser), valueDeser);
}

mlir::StringAttr AttrDeserializer::deserializeMLIRStringAttr(ModuleInfo &mInfo, MLIRStringAttr pAttr) {
  auto valueDeser = pAttr.value();

  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  return mlir::StringAttr::get(valueDeser, mlir::cast<mlir::Type>(typeDeser));
}

mlir::TypeAttr AttrDeserializer::deserializeMLIRTypeAttr(ModuleInfo &mInfo, MLIRTypeAttr pAttr) {
  auto valueDeser = Deserializer::getType(mInfo, pAttr.value());
  return mlir::TypeAttr::get(valueDeser);
}

mlir::UnitAttr AttrDeserializer::deserializeMLIRUnitAttr(ModuleInfo &mInfo, MLIRUnitAttr pAttr) {
  return mlir::UnitAttr::get(&mInfo.ctx);
}

mlir::FlatSymbolRefAttr AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(ModuleInfo &mInfo, MLIRFlatSymbolRefAttr pAttr) {
  auto rootReferenceDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.root_reference());
  return mlir::FlatSymbolRefAttr::get(rootReferenceDeser);
}

mlir::DenseI32ArrayAttr AttrDeserializer::deserializeMLIRDenseI32ArrayAttr(ModuleInfo &mInfo, MLIRDenseI32ArrayAttr pAttr) {
  std::vector<int> contentDeser;
  auto sz = pAttr.raw_data_size();
  for (int i = 0; i < sz; i++) {
    contentDeser.push_back(pAttr.raw_data(i));
  }
  return mlir::DenseI32ArrayAttr::get(&mInfo.ctx, contentDeser);
}

mlir::Location AttrDeserializer::deserializeMLIRLocation(ModuleInfo &mInfo, MLIRLocation pAttr) {
  switch (pAttr.location_case()) {
    case MLIRLocation::LocationCase::kCallSiteLoc: {
      return AttrDeserializer::deserializeMLIRCallSiteLoc(mInfo, pAttr.call_site_loc());
    } break;
    case MLIRLocation::LocationCase::kFileLineColLoc: {
      return AttrDeserializer::deserializeMLIRFileLineColLoc(mInfo, pAttr.file_line_col_loc());
    } break;
    case MLIRLocation::LocationCase::kFusedLoc: {
      return AttrDeserializer::deserializeMLIRFusedLoc(mInfo, pAttr.fused_loc());
    } break;
    case MLIRLocation::LocationCase::kNameLoc: {
      return AttrDeserializer::deserializeMLIRNameLoc(mInfo, pAttr.name_loc());
    } break;
    case MLIRLocation::LocationCase::kOpaqueLoc: {
      return AttrDeserializer::deserializeMLIROpaqueLoc(mInfo, pAttr.opaque_loc());
    } break;
    case MLIRLocation::LocationCase::kUnknownLoc: {
      return AttrDeserializer::deserializeMLIRUnknownLoc(mInfo, pAttr.unknown_loc());
    } break;
    default:
      llvm_unreachable("NYI");
      break;
  };
}

cir::LangAttr AttrDeserializer::deserializeCIRLangAttr(ModuleInfo &mInfo, CIRLangAttr pAttr) {
  auto langDeser = EnumDeserializer::deserializeCIRSourceLanguage(pAttr.lang());
  auto lAttr = cir::SourceLanguageAttr::get(&mInfo.ctx, langDeser);
  return cir::LangAttr::get(&mInfo.ctx, lAttr);
}

cir::AddressSpaceAttr AttrDeserializer::deserializeCIRAddressSpaceAttr(ModuleInfo &mInfo, CIRAddressSpaceAttr pAttr) {
  auto valueDeser = pAttr.value();
  return cir::AddressSpaceAttr::get(&mInfo.ctx, valueDeser);
}

cir::AnnotationAttr AttrDeserializer::deserializeCIRAnnotationAttr(ModuleInfo &mInfo, CIRAnnotationAttr pAttr) {
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.name());
  auto argsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.args());
  return cir::AnnotationAttr::get(&mInfo.ctx, nameDeser, argsDeser);
}

cir::BitfieldInfoAttr AttrDeserializer::deserializeCIRBitfieldInfoAttr(ModuleInfo &mInfo, CIRBitfieldInfoAttr pAttr) {
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.name());
  auto storage_typeDeser = Deserializer::getType(mInfo, pAttr.storage_type());
  auto sizeDeser = pAttr.size();
  auto offsetDeser = pAttr.offset();
  auto is_signedDeser = pAttr.is_signed();
  return cir::BitfieldInfoAttr::get(&mInfo.ctx, nameDeser, storage_typeDeser, sizeDeser, offsetDeser, is_signedDeser);
}

cir::BoolAttr AttrDeserializer::deserializeCIRBoolAttr(ModuleInfo &mInfo, CIRBoolAttr pAttr) {
  auto typeDeser = Deserializer::getType(mInfo, pAttr.type());
  auto valueDeser = pAttr.value();
  return cir::BoolAttr::get(&mInfo.ctx, mlir::cast<cir::BoolType>(typeDeser), valueDeser);
}

cir::TBAAAttr AttrDeserializer::deserializeCIRTBAAAttr(ModuleInfo &mInfo, CIRTBAAAttr pAttr) {
  return cir::TBAAAttr::get(&mInfo.ctx);
}

cir::CatchAllAttr AttrDeserializer::deserializeCIRCatchAllAttr(ModuleInfo &mInfo, CIRCatchAllAttr pAttr) {
  return cir::CatchAllAttr::get(&mInfo.ctx);
}

cir::CatchUnwindAttr AttrDeserializer::deserializeCIRCatchUnwindAttr(ModuleInfo &mInfo, CIRCatchUnwindAttr pAttr) {
  return cir::CatchUnwindAttr::get(&mInfo.ctx);
}

cir::CmpThreeWayInfoAttr AttrDeserializer::deserializeCIRCmpThreeWayInfoAttr(ModuleInfo &mInfo, CIRCmpThreeWayInfoAttr pAttr) {
  auto orderingDeser = EnumDeserializer::deserializeCIRCmpOrdering(pAttr.ordering());
  auto ltDeser = pAttr.lt();
  auto eqDeser = pAttr.eq();
  auto gtDeser = pAttr.gt();

  std::optional<int64_t> unorderedDeser;
  if (pAttr.has_unordered()) {
    auto elem = pAttr.unordered();
    unorderedDeser = elem;
  }
  return cir::CmpThreeWayInfoAttr::get(&mInfo.ctx, orderingDeser, ltDeser, eqDeser, gtDeser, unorderedDeser);
}

cir::ComplexAttr AttrDeserializer::deserializeCIRComplexAttr(ModuleInfo &mInfo, CIRComplexAttr pAttr) {
  auto typeDeser = Deserializer::getType(mInfo, pAttr.type());
  auto realDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, pAttr.real());
  auto imagDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, pAttr.imag());
  return cir::ComplexAttr::get(&mInfo.ctx, mlir::cast<cir::ComplexType>(typeDeser), mlir::cast<mlir::TypedAttr>(realDeser), mlir::cast<mlir::TypedAttr>(imagDeser));
}

cir::ConstArrayAttr AttrDeserializer::deserializeCIRConstArrayAttr(ModuleInfo &mInfo, CIRConstArrayAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto eltsDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, pAttr.elts());
  auto trailingZerosNumDeser = pAttr.trailing_zeros_num();
  return cir::ConstArrayAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser), eltsDeser, trailingZerosNumDeser);
}

cir::ConstPtrAttr AttrDeserializer::deserializeCIRConstPtrAttr(ModuleInfo &mInfo, CIRConstPtrAttr pAttr) {
  auto typeDeser = Deserializer::getType(mInfo, pAttr.type());
  auto valueDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pAttr.value());
  return cir::ConstPtrAttr::get(&mInfo.ctx, mlir::cast<cir::PointerType>(typeDeser), valueDeser);
}

cir::ConstStructAttr AttrDeserializer::deserializeCIRConstStructAttr(ModuleInfo &mInfo, CIRConstStructAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto membersDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.members());
  return cir::ConstStructAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser), membersDeser);
}

cir::ConstVectorAttr AttrDeserializer::deserializeCIRConstVectorAttr(ModuleInfo &mInfo, CIRConstVectorAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto eltsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.elts());
  return cir::ConstVectorAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser), eltsDeser);
}

cir::ConvergentAttr AttrDeserializer::deserializeCIRConvergentAttr(ModuleInfo &mInfo, CIRConvergentAttr pAttr) {
  return cir::ConvergentAttr::get(&mInfo.ctx);
}

cir::DataMemberAttr AttrDeserializer::deserializeCIRDataMemberAttr(ModuleInfo &mInfo, CIRDataMemberAttr pAttr) {
  auto typeDeser = Deserializer::getType(mInfo, pAttr.type());

  std::optional<unsigned> member_indexDeser;
  if (pAttr.has_member_index()) {
    auto elem = pAttr.member_index();
    member_indexDeser = elem;
  }
  return cir::DataMemberAttr::get(&mInfo.ctx, mlir::cast<cir::DataMemberType>(typeDeser), member_indexDeser);
}

cir::DynamicCastInfoAttr AttrDeserializer::deserializeCIRDynamicCastInfoAttr(ModuleInfo &mInfo, CIRDynamicCastInfoAttr pAttr) {
  auto srcRttiDeser = AttrDeserializer::deserializeCIRGlobalViewAttr(mInfo, pAttr.src_rtti());
  auto destRttiDeser = AttrDeserializer::deserializeCIRGlobalViewAttr(mInfo, pAttr.dest_rtti());
  auto runtimeFuncDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pAttr.runtime_func());
  auto badCastFuncDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pAttr.bad_cast_func());
  auto offsetHintDeser = AttrDeserializer::deserializeCIRIntAttr(mInfo, pAttr.offset_hint());
  return cir::DynamicCastInfoAttr::get(&mInfo.ctx, srcRttiDeser, destRttiDeser, runtimeFuncDeser, badCastFuncDeser, offsetHintDeser);
}

cir::ExtraFuncAttributesAttr AttrDeserializer::deserializeCIRExtraFuncAttributesAttr(ModuleInfo &mInfo, CIRExtraFuncAttributesAttr pAttr) {
  auto elementsDeser = AttrDeserializer::deserializeMLIRDictionaryAttr(mInfo, pAttr.elements());
  return cir::ExtraFuncAttributesAttr::get(&mInfo.ctx, elementsDeser);
}

cir::FPAttr AttrDeserializer::deserializeCIRFPAttr(ModuleInfo &mInfo, CIRFPAttr pAttr) {
  auto typeDeser = Deserializer::getType(mInfo, pAttr.type());
  auto valueDeser = deserializeAPFloat(pAttr.value());
  return cir::FPAttr::get(&mInfo.ctx, mlir::cast<cir::CIRFPTypeInterface>(typeDeser), valueDeser);
}

cir::GlobalAnnotationValuesAttr AttrDeserializer::deserializeCIRGlobalAnnotationValuesAttr(ModuleInfo &mInfo, CIRGlobalAnnotationValuesAttr pAttr) {
  auto annotationsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.annotations());
  return cir::GlobalAnnotationValuesAttr::get(&mInfo.ctx, annotationsDeser);
}

cir::GlobalCtorAttr AttrDeserializer::deserializeCIRGlobalCtorAttr(ModuleInfo &mInfo, CIRGlobalCtorAttr pAttr) {
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.name());
  auto priorityDeser = pAttr.priority();
  return cir::GlobalCtorAttr::get(&mInfo.ctx, nameDeser, priorityDeser);
}

cir::GlobalDtorAttr AttrDeserializer::deserializeCIRGlobalDtorAttr(ModuleInfo &mInfo, CIRGlobalDtorAttr pAttr) {
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pAttr.name());
  auto priorityDeser = pAttr.priority();
  return cir::GlobalDtorAttr::get(&mInfo.ctx, nameDeser, priorityDeser);
}

cir::GlobalViewAttr AttrDeserializer::deserializeCIRGlobalViewAttr(ModuleInfo &mInfo, CIRGlobalViewAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto symbolDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pAttr.symbol());

  mlir::ArrayAttr indicesDeser;
  if (pAttr.has_indices()) {
    auto elem = pAttr.indices();
    indicesDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return cir::GlobalViewAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser), symbolDeser, indicesDeser);
}

cir::InactiveUnionFieldAttr AttrDeserializer::deserializeCIRInactiveUnionFieldAttr(ModuleInfo &mInfo, CIRInactiveUnionFieldAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  return cir::InactiveUnionFieldAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser));
}

cir::InlineAttr AttrDeserializer::deserializeCIRInlineAttr(ModuleInfo &mInfo, CIRInlineAttr pAttr) {
  auto valueDeser = EnumDeserializer::deserializeCIRInlineKind(pAttr.value());
  return cir::InlineAttr::get(&mInfo.ctx, valueDeser);
}

cir::IntAttr AttrDeserializer::deserializeCIRIntAttr(ModuleInfo &mInfo, CIRIntAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto valueDeser = deserializeAPInt(typeDeser, pAttr.value());
  return cir::IntAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser), valueDeser);
}

cir::MethodAttr AttrDeserializer::deserializeCIRMethodAttr(ModuleInfo &mInfo, CIRMethodAttr pAttr) {
  auto typeDeser = Deserializer::getType(mInfo, pAttr.type());

  std::optional<mlir::FlatSymbolRefAttr> symbolDeser;
  if (pAttr.has_symbol()) {
    auto elem = pAttr.symbol();
    symbolDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }

  std::optional<uint64_t> vtable_offsetDeser;
  if (pAttr.has_vtable_offset()) {
    auto elem = pAttr.vtable_offset();
    vtable_offsetDeser = elem;
  }
  return cir::MethodAttr::get(&mInfo.ctx, mlir::cast<cir::MethodType>(typeDeser), symbolDeser, vtable_offsetDeser);
}

cir::NoThrowAttr AttrDeserializer::deserializeCIRNoThrowAttr(ModuleInfo &mInfo, CIRNoThrowAttr pAttr) {
  return cir::NoThrowAttr::get(&mInfo.ctx);
}

cir::OpenCLKernelArgMetadataAttr AttrDeserializer::deserializeCIROpenCLKernelArgMetadataAttr(ModuleInfo &mInfo, CIROpenCLKernelArgMetadataAttr pAttr) {
  auto addr_spaceDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.addr_space());
  auto access_qualDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.access_qual());
  auto typeDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.type());
  auto base_typeDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.base_type());
  auto type_qualDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.type_qual());

  mlir::ArrayAttr nameDeser;
  if (pAttr.has_name()) {
    auto elem = pAttr.name();
    nameDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return cir::OpenCLKernelArgMetadataAttr::get(&mInfo.ctx, addr_spaceDeser, access_qualDeser, mlir::cast<mlir::ArrayAttr>(typeDeser), base_typeDeser, type_qualDeser, nameDeser);
}

cir::OpenCLKernelAttr AttrDeserializer::deserializeCIROpenCLKernelAttr(ModuleInfo &mInfo, CIROpenCLKernelAttr pAttr) {
  return cir::OpenCLKernelAttr::get(&mInfo.ctx);
}

cir::OpenCLKernelMetadataAttr AttrDeserializer::deserializeCIROpenCLKernelMetadataAttr(ModuleInfo &mInfo, CIROpenCLKernelMetadataAttr pAttr) {
  mlir::ArrayAttr work_group_size_hintDeser;
  if (pAttr.has_work_group_size_hint()) {
    auto elem = pAttr.work_group_size_hint();
    work_group_size_hintDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }

  mlir::ArrayAttr reqd_work_group_sizeDeser;
  if (pAttr.has_reqd_work_group_size()) {
    auto elem = pAttr.reqd_work_group_size();
    reqd_work_group_sizeDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }

  mlir::TypeAttr vec_type_hintDeser;
  if (pAttr.has_vec_type_hint()) {
    auto elem = pAttr.vec_type_hint();
    vec_type_hintDeser = AttrDeserializer::deserializeMLIRTypeAttr(mInfo, elem);
  }

  std::optional<bool> vec_type_hint_signednessDeser;
  if (pAttr.has_vec_type_hint_signedness()) {
    auto elem = pAttr.vec_type_hint_signedness();
    vec_type_hint_signednessDeser = elem;
  }

  mlir::IntegerAttr intel_reqd_sub_group_sizeDeser;
  if (pAttr.has_intel_reqd_sub_group_size()) {
    auto elem = pAttr.intel_reqd_sub_group_size();
    intel_reqd_sub_group_sizeDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, elem);
  }
  return cir::OpenCLKernelMetadataAttr::get(&mInfo.ctx, work_group_size_hintDeser, reqd_work_group_sizeDeser, vec_type_hintDeser, vec_type_hint_signednessDeser, intel_reqd_sub_group_sizeDeser);
}

cir::OpenCLKernelUniformWorkGroupSizeAttr AttrDeserializer::deserializeCIROpenCLKernelUniformWorkGroupSizeAttr(ModuleInfo &mInfo, CIROpenCLKernelUniformWorkGroupSizeAttr pAttr) {
  return cir::OpenCLKernelUniformWorkGroupSizeAttr::get(&mInfo.ctx);
}

cir::OpenCLVersionAttr AttrDeserializer::deserializeCIROpenCLVersionAttr(ModuleInfo &mInfo, CIROpenCLVersionAttr pAttr) {
  auto major_versionDeser = pAttr.major_version();
  auto minor_versionDeser = pAttr.minor_version();
  return cir::OpenCLVersionAttr::get(&mInfo.ctx, major_versionDeser, minor_versionDeser);
}

cir::OptNoneAttr AttrDeserializer::deserializeCIROptNoneAttr(ModuleInfo &mInfo, CIROptNoneAttr pAttr) {
  return cir::OptNoneAttr::get(&mInfo.ctx);
}

cir::StructLayoutAttr AttrDeserializer::deserializeCIRStructLayoutAttr(ModuleInfo &mInfo, CIRStructLayoutAttr pAttr) {
  auto sizeDeser = pAttr.size();
  auto alignmentDeser = pAttr.alignment();
  auto paddedDeser = pAttr.padded();
  auto largest_memberDeser = Deserializer::getType(mInfo, pAttr.largest_member());
  auto offsetsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.offsets());
  return cir::StructLayoutAttr::get(&mInfo.ctx, sizeDeser, alignmentDeser, paddedDeser, largest_memberDeser, offsetsDeser);
}

cir::TypeInfoAttr AttrDeserializer::deserializeCIRTypeInfoAttr(ModuleInfo &mInfo, CIRTypeInfoAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto dataDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.data());
  return cir::TypeInfoAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser), dataDeser);
}

cir::UndefAttr AttrDeserializer::deserializeCIRUndefAttr(ModuleInfo &mInfo, CIRUndefAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  return cir::UndefAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser));
}

cir::VTableAttr AttrDeserializer::deserializeCIRVTableAttr(ModuleInfo &mInfo, CIRVTableAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  auto vtable_dataDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pAttr.vtable_data());
  return cir::VTableAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser), vtable_dataDeser);
}

cir::VisibilityAttr AttrDeserializer::deserializeCIRVisibilityAttr(ModuleInfo &mInfo, CIRVisibilityAttr pAttr) {
  auto valueDeser = EnumDeserializer::deserializeCIRVisibilityKind(pAttr.value());
  return cir::VisibilityAttr::get(&mInfo.ctx, valueDeser);
}

cir::ZeroAttr AttrDeserializer::deserializeCIRZeroAttr(ModuleInfo &mInfo, CIRZeroAttr pAttr) {
  mlir::Type typeDeser;
  if (pAttr.has_type()) {
    auto elem = pAttr.type();
    typeDeser = Deserializer::getType(mInfo, elem);
  }
  return cir::ZeroAttr::get(&mInfo.ctx, mlir::cast<mlir::Type>(typeDeser));
}

cir::AsmFlavorAttr AttrDeserializer::deserializeCIRAsmFlavorAttr(ModuleInfo &mInfo, CIRAsmFlavorAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRAsmFlavor(pAttr.value());
  return cir::AsmFlavorAttr::get(&mInfo.ctx, enumDeser);
}

cir::AtomicFetchKindAttr AttrDeserializer::deserializeCIRAtomicFetchKindAttr(ModuleInfo &mInfo, CIRAtomicFetchKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRAtomicFetchKind(pAttr.value());
  return cir::AtomicFetchKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::AwaitKindAttr AttrDeserializer::deserializeCIRAwaitKindAttr(ModuleInfo &mInfo, CIRAwaitKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRAwaitKind(pAttr.value());
  return cir::AwaitKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::BinOpKindAttr AttrDeserializer::deserializeCIRBinOpKindAttr(ModuleInfo &mInfo, CIRBinOpKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRBinOpKind(pAttr.value());
  return cir::BinOpKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::BinOpOverflowKindAttr AttrDeserializer::deserializeCIRBinOpOverflowKindAttr(ModuleInfo &mInfo, CIRBinOpOverflowKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRBinOpOverflowKind(pAttr.value());
  return cir::BinOpOverflowKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::CallingConvAttr AttrDeserializer::deserializeCIRCallingConvAttr(ModuleInfo &mInfo, CIRCallingConvAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRCallingConv(pAttr.value());
  return cir::CallingConvAttr::get(&mInfo.ctx, enumDeser);
}

cir::CaseOpKindAttr AttrDeserializer::deserializeCIRCaseOpKindAttr(ModuleInfo &mInfo, CIRCaseOpKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRCaseOpKind(pAttr.value());
  return cir::CaseOpKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::CastKindAttr AttrDeserializer::deserializeCIRCastKindAttr(ModuleInfo &mInfo, CIRCastKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRCastKind(pAttr.value());
  return cir::CastKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::CatchParamKindAttr AttrDeserializer::deserializeCIRCatchParamKindAttr(ModuleInfo &mInfo, CIRCatchParamKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRCatchParamKind(pAttr.value());
  return cir::CatchParamKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::CmpOpKindAttr AttrDeserializer::deserializeCIRCmpOpKindAttr(ModuleInfo &mInfo, CIRCmpOpKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRCmpOpKind(pAttr.value());
  return cir::CmpOpKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::CmpOrderingAttr AttrDeserializer::deserializeCIRCmpOrderingAttr(ModuleInfo &mInfo, CIRCmpOrderingAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRCmpOrdering(pAttr.value());
  return cir::CmpOrderingAttr::get(&mInfo.ctx, enumDeser);
}

cir::ComplexBinOpKindAttr AttrDeserializer::deserializeCIRComplexBinOpKindAttr(ModuleInfo &mInfo, CIRComplexBinOpKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRComplexBinOpKind(pAttr.value());
  return cir::ComplexBinOpKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::ComplexRangeKindAttr AttrDeserializer::deserializeCIRComplexRangeKindAttr(ModuleInfo &mInfo, CIRComplexRangeKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRComplexRangeKind(pAttr.value());
  return cir::ComplexRangeKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::DynamicCastKindAttr AttrDeserializer::deserializeCIRDynamicCastKindAttr(ModuleInfo &mInfo, CIRDynamicCastKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRDynamicCastKind(pAttr.value());
  return cir::DynamicCastKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::GlobalLinkageKindAttr AttrDeserializer::deserializeCIRGlobalLinkageKindAttr(ModuleInfo &mInfo, CIRGlobalLinkageKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRGlobalLinkageKind(pAttr.value());
  return cir::GlobalLinkageKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::InlineKindAttr AttrDeserializer::deserializeCIRInlineKindAttr(ModuleInfo &mInfo, CIRInlineKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRInlineKind(pAttr.value());
  return cir::InlineKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::MemOrderAttr AttrDeserializer::deserializeCIRMemOrderAttr(ModuleInfo &mInfo, CIRMemOrderAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRMemOrder(pAttr.value());
  return cir::MemOrderAttr::get(&mInfo.ctx, enumDeser);
}

cir::SignedOverflowBehaviorAttr AttrDeserializer::deserializeCIRSignedOverflowBehaviorAttr(ModuleInfo &mInfo, CIRSignedOverflowBehaviorAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRSignedOverflowBehavior(pAttr.value());
  return cir::SignedOverflowBehaviorAttr::get(&mInfo.ctx, enumDeser);
}

cir::SizeInfoTypeAttr AttrDeserializer::deserializeCIRSizeInfoTypeAttr(ModuleInfo &mInfo, CIRSizeInfoTypeAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRSizeInfoType(pAttr.value());
  return cir::SizeInfoTypeAttr::get(&mInfo.ctx, enumDeser);
}

cir::SourceLanguageAttr AttrDeserializer::deserializeCIRSourceLanguageAttr(ModuleInfo &mInfo, CIRSourceLanguageAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRSourceLanguage(pAttr.value());
  return cir::SourceLanguageAttr::get(&mInfo.ctx, enumDeser);
}

cir::TLS_ModelAttr AttrDeserializer::deserializeCIRTLSModelAttr(ModuleInfo &mInfo, CIRTLSModelAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRTLSModel(pAttr.value());
  return cir::TLS_ModelAttr::get(&mInfo.ctx, enumDeser);
}

cir::UnaryOpKindAttr AttrDeserializer::deserializeCIRUnaryOpKindAttr(ModuleInfo &mInfo, CIRUnaryOpKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRUnaryOpKind(pAttr.value());
  return cir::UnaryOpKindAttr::get(&mInfo.ctx, enumDeser);
}

cir::VisibilityKindAttr AttrDeserializer::deserializeCIRVisibilityKindAttr(ModuleInfo &mInfo, CIRVisibilityKindAttr pAttr) {
  auto enumDeser = EnumDeserializer::deserializeCIRVisibilityKind(pAttr.value());
  return cir::VisibilityKindAttr::get(&mInfo.ctx, enumDeser);
}

// clang-format on
